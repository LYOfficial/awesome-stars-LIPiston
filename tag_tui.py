# æœ‰ğŸ›bug
# é«˜äº®çš„ä»“åº“å’Œé€‰ä¸­çš„ä»“åº“åœ¨æœªæ‰“æ ‡ç­¾æ¨¡å¼ä¸‹ä¼šæœ‰é—®é¢˜
# ä¸Šä¸‹ç§»åŠ¨æ—¶æœ‰é—®é¢˜ï¼Œä¼šä»æœ€ä¸‹é¢çªç„¶åˆ°æœ€ä¸Šé¢ç„¶ååˆå›æ¥

import urwid
import json
import os
import sys
import logging
from datetime import datetime

DATA_FILE = 'data.json'
TAG_FILE = 'tagged_full_names.json'
LOG_DIR = 'logs'
EXPORT_FILE = 'tagged_repositories.md'

# è®¾ç½®æ—¥å¿—
def setup_logging():
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)
    
    log_file = os.path.join(LOG_DIR, f'tag_app_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log')
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file, encoding='utf-8')
        ]
    )
    return logging.getLogger(__name__)

logger = setup_logging()

def load_full_names():
    try:
        with open(DATA_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
        full_names = []
        for category, items in data.items():
            if isinstance(items, list):
                for item in items:
                    if isinstance(item, dict) and 'full_name' in item:
                        # åŒæ—¶åŠ è½½ full_name, category, description å’Œ html_url
                        full_names.append({
                            'category': category,
                            'full_name': item['full_name'],
                            'description': item.get('description', 'æ— æè¿°'), # è·å– descriptionï¼Œå¦‚æœæ²¡æœ‰åˆ™æ˜¾ç¤º"æ— æè¿°"
                            'html_url': item.get('html_url', '') # è·å– html_urlï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸ºç©ºå­—ç¬¦ä¸²
                        })
        logger.info(f"æˆåŠŸåŠ è½½ {len(full_names)} ä¸ªä»“åº“ä¿¡æ¯")
        return full_names
    except FileNotFoundError:
        logger.error(f"æ‰¾ä¸åˆ°æ•°æ®æ–‡ä»¶ {DATA_FILE}")
        print(f"é”™è¯¯ï¼šæ‰¾ä¸åˆ°æ•°æ®æ–‡ä»¶ {DATA_FILE}")
        sys.exit(1)
    except json.JSONDecodeError:
        logger.error(f"{DATA_FILE} æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®")
        print(f"é”™è¯¯ï¼š{DATA_FILE} æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®")
        sys.exit(1)

def save_tags(tag_dict):
    try:
        with open(TAG_FILE, 'w', encoding='utf-8') as f:
            json.dump(tag_dict, f, ensure_ascii=False, indent=2)
        logger.info(f"æˆåŠŸä¿å­˜æ ‡ç­¾åˆ° {TAG_FILE}")
    except Exception as e:
        logger.error(f"ä¿å­˜æ ‡ç­¾æ—¶å‡ºé”™ï¼š{str(e)}")
        print(f"ä¿å­˜æ ‡ç­¾æ—¶å‡ºé”™ï¼š{str(e)}")

def load_tags():
    try:
        with open(TAG_FILE, 'r', encoding='utf-8') as f:
            tags = json.load(f)
        logger.info(f"æˆåŠŸåŠ è½½ç°æœ‰æ ‡ç­¾ä» {TAG_FILE}")
        return tags
    except FileNotFoundError:
        logger.info(f"æ‰¾ä¸åˆ°æ ‡ç­¾æ–‡ä»¶ {TAG_FILE}ï¼Œå°†åˆ›å»ºæ–°çš„æ ‡ç­¾æ–‡ä»¶")
        return {}
    except json.JSONDecodeError:
        logger.error(f"æ ‡ç­¾æ–‡ä»¶ {TAG_FILE} æ ¼å¼ä¸æ­£ç¡®")
        return {}
    except Exception as e:
        logger.error(f"åŠ è½½æ ‡ç­¾æ—¶å‡ºé”™ï¼š{str(e)}")
        return {}

def export_markdown(tags, full_names):
    try:
        # æ„å»º full_name åˆ°ä»“åº“ä¿¡æ¯çš„æ˜ å°„ï¼Œæ–¹ä¾¿æŸ¥æ‰¾
        repo_lookup = {item['full_name']: item for item in full_names}
        
        # æŒ‰æ ‡ç­¾åˆ†ç»„ä»“åº“
        tags_to_repos = {}
        for full_name, tag_list in tags.items():
            if full_name in repo_lookup:
                repo_info = repo_lookup[full_name]
                for tag in tag_list:
                    if tag not in tags_to_repos:
                        tags_to_repos[tag] = []
                    tags_to_repos[tag].append(repo_info)
        
        with open(EXPORT_FILE, 'w', encoding='utf-8') as f:
            f.write("# Tagged Repositories\n\n")
            
            # æŒ‰æ ‡ç­¾åæ’åºè¾“å‡º
            for tag in sorted(tags_to_repos.keys()):
                f.write(f"## {tag}\n")
                # æŒ‰ full_name æ’åºä»“åº“
                for repo in sorted(tags_to_repos[tag], key=lambda x: x['full_name']):
                    description = repo.get('description', 'æ— æè¿°')
                    html_url = repo.get('html_url', '')
                    
                    if html_url:
                         f.write(f"- [{repo['full_name']}]({html_url}) - {description}\n")
                    else:
                         f.write(f"- {repo['full_name']} - {description}\n")
                f.write("\n")
        
        logger.info(f"æˆåŠŸå¯¼å‡º Markdown åˆ° {EXPORT_FILE}")
        return f"æˆåŠŸå¯¼å‡ºæ ‡ç­¾åˆ° {EXPORT_FILE}"
        
    except Exception as e:
        logger.error(f"å¯¼å‡º Markdown æ—¶å‡ºé”™ï¼š{str(e)}")
        return f"å¯¼å‡º Markdown æ—¶å‡ºé”™ï¼š{str(e)}"

class TagApp:
    def make_items(self, view_mode, focus_position=None):
        items = []
        if view_mode == 'all':
            tagged_repos = []
            untagged_repos = []
            for item in self.full_names:
                full_name = item['full_name']
                tags_list = self.tags.get(full_name, []) 
                if tags_list:
                    tagged_repos.append((item, tags_list))
                else:
                    untagged_repos.append(item)
            for item, tags_list in tagged_repos:
                tag_str = ' '.join(tags_list)
                txt = f"[{item['category']}] {item['full_name']}  æ ‡ç­¾: {tag_str}"
                w = urwid.Text(txt)
                items.append(w)
            if untagged_repos:
                items.append(urwid.Divider())
                items.append(urwid.Text("--- æœªæ‰“æ ‡ç­¾çš„ä»“åº“ ---"))
                items.append(urwid.Divider())
                for item in untagged_repos:
                    txt = f"[{item['category']}] {item['full_name']}  æ ‡ç­¾: æ— "
                    w = urwid.Text(txt)
                    items.append(w)
        elif view_mode == 'untagged':
            items.append(urwid.Text("--- æœªæ‰“æ ‡ç­¾çš„ä»“åº“ ---"))
            items.append(urwid.Divider())
            has_untagged = False
            for item in self.full_names:
                full_name = item['full_name']
                tags_list = self.tags.get(full_name, [])
                if not tags_list:
                    txt = f"[{item['category']}] {item['full_name']}  æ ‡ç­¾: æ— "
                    w = urwid.Text(txt)
                    items.append(w)
                    has_untagged = True
            if not has_untagged:
                items.append(urwid.Text("æ‰€æœ‰ä»“åº“éƒ½å·²æ‰“æ ‡ç­¾ï¼"))
        return items

    def wrap_focusable_items(self, items):
        # åªåŒ…è£¹çœŸæ­£å¯é€‰çš„ä»“åº“é¡¹ï¼Œä¸”è¿”å› (focusable_items, focus_map)
        focusable_items = []
        focus_map = []
        for w in items:
            if isinstance(w, urwid.Text):
                text = w.get_text()[0]
                if not text.startswith('---') and not text.startswith('æ‰€æœ‰ä»“åº“'):
                    focusable_items.append(urwid.AttrMap(w, None, 'focus'))
                    focus_map.append(True)
                else:
                    focusable_items.append(w)
                    focus_map.append(False)
            else:
                focusable_items.append(w)
                focus_map.append(False)
        return focusable_items, focus_map

    def get_logical_index(self, real_idx):
        # real_idxä¸ºfocusable_itemsä¸­çš„ç´¢å¼•ï¼Œè¿”å›ç¬¬å‡ ä¸ªå¯é€‰é¡¹
        items = self.make_items(self.view_mode)
        _, focus_map = self.wrap_focusable_items(items)
        count = -1
        for i, is_focus in enumerate(focus_map):
            if is_focus:
                count += 1
            if i == real_idx:
                return count
        return 0

    def get_focusable_index(self, n):
        # nä¸ºé€»è¾‘é€‰ä¸­é¡¹ï¼ˆå¦‚listbox.focus_positionï¼‰ï¼Œè¿”å›ç¬¬nä¸ªå¯é€‰é¡¹åœ¨focusable_itemsä¸­çš„çœŸå®ç´¢å¼•
        items = self.make_items(self.view_mode)
        _, focus_map = self.wrap_focusable_items(items)
        count = -1
        for i, is_focus in enumerate(focus_map):
            if is_focus:
                count += 1
            if count == n:
                return i
        return 0

    def __init__(self, full_names):
        self.full_names = full_names
        
        # åˆå§‹åŒ–æ ‡ç­¾å­—å…¸ï¼Œå¹¶å°è¯•åŠ è½½ç°æœ‰æ ‡ç­¾
        self.tags = {item['full_name']: [] for item in full_names}
        existing_tags = load_tags()
        # åˆå¹¶ç°æœ‰æ ‡ç­¾ï¼Œä¿ç•™ load_full_names ä¸­åŠ è½½çš„ description å’Œ html_url
        for full_name, tag_list in existing_tags.items():
            if full_name in self.tags:
                self.tags[full_name] = tag_list

        self.current = 0
        # æ›´æ–°ä¸»ç•Œé¢çš„è¾“å…¥æç¤º
        self.edit = urwid.Edit(('editcp', u"è¾“å…¥æ ‡ç­¾(ç©ºæ ¼åˆ†éš”): "))
        
        # åˆå§‹åŒ–è§†å›¾æ¨¡å¼
        self.view_mode = 'all' # 'all' æˆ– 'untagged'
        
        # æ›´æ–°ä½¿ç”¨è¯´æ˜ï¼Œæ·»åŠ åˆ‡æ¢è§†å›¾å’Œå¯¼å‡º Markdown çš„æç¤º
        self.info = urwid.Text(u"ä½¿ç”¨è¯´æ˜ï¼š\n1. ä½¿ç”¨ä¸Šä¸‹é”®é€‰æ‹©ä»“åº“\n2. æŒ‰å›è½¦é”®æ‰“å¼€æ ‡ç­¾è¾“å…¥çª—å£\n3. è¾“å…¥æ ‡ç­¾ï¼ˆç”¨ç©ºæ ¼åˆ†éš”ï¼‰\n4. ç‚¹å‡»ç¡®å®šä¿å­˜\n5. æŒ‰ q é”®ä¿å­˜å¹¶é€€å‡º\n6. æŒ‰ m é”®å¯¼å‡ºMarkdown\n7. ä½¿ç”¨å·¦å³é”®åˆ‡æ¢è§†å›¾ (å…¨éƒ¨/æœªæ‰“æ ‡ç­¾)")
        
        # åªç”¨ AttrMap åŒ…è£¹å¯é€‰é¡¹ï¼Œå¹¶åœ¨ SimpleFocusListWalker é‡Œ
        items = self.make_items(self.view_mode)
        focusable_items, _ = self.wrap_focusable_items(items)
        self.listbox = urwid.ListBox(urwid.SimpleFocusListWalker(focusable_items))
        
        # åˆ›å»ºä¸€ä¸ªç”¨äºæ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯çš„æ–‡æœ¬ç»„ä»¶
        self.status_text = urwid.Text(u"")
        
        # å¿…é¡»å…ˆåˆ›å»º self.frameï¼Œåé¢ update_list ä¸è¦å†é‡æ–°èµ‹å€¼ self.listbox.body
        self.frame = urwid.Frame(
            urwid.AttrWrap(self.listbox, 'body'),
            footer=urwid.Pile([self.info, self.edit, self.status_text])
        )
        logger.info("TagApp åˆå§‹åŒ–å®Œæˆ")

    def update_list(self):
        items = self.make_items(self.view_mode)
        focusable_items, focus_map = self.wrap_focusable_items(items)
        # ä¿æŒé€»è¾‘é€‰ä¸­é¡¹ä¸å˜
        logical_idx = self.get_logical_index(self.listbox.focus_position)
        self.listbox.body[:] = focusable_items
        # é‡æ–°è®¾ç½®ç„¦ç‚¹åˆ°é€»è¾‘é€‰ä¸­é¡¹
        self.listbox.focus_position = self.get_focusable_index(logical_idx)
        logger.debug(f"æ›´æ–°åˆ—è¡¨æ˜¾ç¤º - è§†å›¾æ¨¡å¼: {self.view_mode}")

    def open_tag_popup(self, idx):
        full_name = self.full_names[idx]['full_name']
        description = self.full_names[idx].get('description', 'æ— æè¿°')
        current_tags = ' '.join(self.tags[full_name])
        logger.info(f"æ‰“å¼€æ ‡ç­¾ç¼–è¾‘çª—å£ - ä»“åº“: {full_name}, å½“å‰æ ‡ç­¾: {current_tags}")
        
        # åˆ›å»ºæ›´æ¸…æ™°çš„è¾“å…¥ç•Œé¢
        header = urwid.Text(('header', f"ä¸ºä»“åº“ {full_name} æ·»åŠ æ ‡ç­¾"))
        
        # æ·»åŠ æè¿°æ–‡æœ¬
        description_text = urwid.Text(f"æè¿°: {description}")
        
        instruction = urwid.Text(('instruction', "è¯·è¾“å…¥æ ‡ç­¾ï¼Œå¤šä¸ªæ ‡ç­¾ç”¨ç©ºæ ¼åˆ†éš”\nä¾‹å¦‚: python web framework"))
        edit = urwid.Edit(('editcp', u"æ ‡ç­¾: "), current_tags)
        
        # æ·»åŠ çŠ¶æ€æ˜¾ç¤º
        status = urwid.Text("")
        
        # åˆ›å»ºæŒ‰é’®
        ok_button = urwid.Button(('button', 'ç¡®å®š'))
        cancel_button = urwid.Button(('button', 'å–æ¶ˆ'))
        
        # ä½¿ç”¨ Pile å‚ç›´æ’åˆ—ç»„ä»¶
        pile = urwid.Pile([
            ('pack', header),
            ('pack', urwid.Divider()),
            ('pack', description_text),
            ('pack', urwid.Divider()),
            ('pack', instruction),
            ('pack', urwid.Divider()),
            ('pack', edit),
            ('pack', urwid.Divider()),
            ('pack', status),
            ('pack', urwid.Divider()),
            ('pack', urwid.GridFlow([
                ok_button,
                cancel_button
            ], cell_width=15, h_sep=2, v_sep=1, align='center'))
        ])
        
        # æ·»åŠ è¾¹æ¡†å’Œå¡«å……
        box = urwid.LineBox(
            urwid.Padding(pile, left=2, right=2),
            title="æ ‡ç­¾ç¼–è¾‘"
        )
        
        # åˆ›å»ºè¦†ç›–å±‚
        overlay = urwid.Overlay(
            box,
            self.frame,
            align='center', width=('relative', 80),
            valign='middle', height=('relative', 60),
            min_width=40,
            min_height=20
        )
        
        def on_ok(button):
            tag_input = edit.edit_text.strip()
            if not tag_input:
                status.set_text(('error', "è¯·è¾“å…¥è‡³å°‘ä¸€ä¸ªæ ‡ç­¾"))
                return
                
            tags = [t.strip() for t in tag_input.split() if t.strip()]
            if not tags:
                status.set_text(('error', "è¯·è¾“å…¥æœ‰æ•ˆçš„æ ‡ç­¾"))
                return
                
            self.tags[full_name] = tags
            logger.info(f"æ›´æ–°æ ‡ç­¾ - ä»“åº“: {full_name}, æ–°æ ‡ç­¾: {tags}")
            self.update_list()
            self.loop.widget = self.frame
            
        def on_cancel(button):
            logger.info(f"å–æ¶ˆæ ‡ç­¾ç¼–è¾‘ - ä»“åº“: {full_name}")
            self.loop.widget = self.frame
            
        urwid.connect_signal(ok_button, 'click', on_ok)
        urwid.connect_signal(cancel_button, 'click', on_cancel)
        
        # è®¾ç½®ç„¦ç‚¹åˆ°è¾“å…¥æ¡†
        self.loop.widget = overlay
        # è®¾ç½® pile çš„ç„¦ç‚¹åˆ°ç¼–è¾‘æ¡†
        pile.focus_position = 6  # edit ç»„ä»¶åœ¨ pile ä¸­çš„ä½ç½®

    def unhandled(self, key):
        if key in ('q', 'Q'):
            logger.info("ç”¨æˆ·é€€å‡ºç¨‹åº")
            save_tags(self.tags)
            raise urwid.ExitMainLoop()
        elif key in ('m', 'M'):
            logger.info("ç”¨æˆ·è¯·æ±‚å¯¼å‡º Markdown")
            # è°ƒç”¨å¯¼å‡ºå‡½æ•°å¹¶æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
            message = export_markdown(self.tags, self.full_names)
            self.status_text.set_text(message)
            logger.info(f"å¯¼å‡ºçŠ¶æ€: {message}")
        elif key == 'left':
            # åˆ‡æ¢åˆ°æ˜¾ç¤ºæ‰€æœ‰ä»“åº“æ¨¡å¼
            if self.view_mode != 'all':
                self.view_mode = 'all'
                self.update_list()
                self.status_text.set_text(u"æ˜¾ç¤ºï¼šæ‰€æœ‰ä»“åº“")
                logger.info("åˆ‡æ¢è§†å›¾ï¼šæ‰€æœ‰ä»“åº“")
        elif key == 'right':
            # åˆ‡æ¢åˆ°åªæ˜¾ç¤ºæœªæ‰“æ ‡ç­¾ä»“åº“æ¨¡å¼
            if self.view_mode != 'untagged':
                self.view_mode = 'untagged'
                self.update_list()
                self.status_text.set_text(u"æ˜¾ç¤ºï¼šæœªæ‰“æ ‡ç­¾çš„ä»“åº“")
                logger.info("åˆ‡æ¢è§†å›¾ï¼šæœªæ‰“æ ‡ç­¾çš„ä»“åº“")
        else:
            # å¦‚æœä¸æ˜¯ä¸Šè¿°ç‰¹æ®ŠæŒ‰é”®ï¼Œåˆ™è°ƒç”¨åŸå§‹çš„æŒ‰é”®å¤„ç†å‡½æ•°
            return key

    def main(self):
        try:
            loop = urwid.MainLoop(
                self.frame,
                palette=[
                    ('body', 'default', 'default'),
                    ('editcp', 'light cyan', 'default'),
                    ('focus', 'light red', 'default'),
                    ('header', 'light green', 'default'),
                    ('instruction', 'light gray', 'default'),
                    ('button', 'light blue', 'default'),
                    ('error', 'light red', 'default')
                ],
                unhandled_input=self.unhandled
            )
            self.loop = loop
            orig_keypress = self.listbox.keypress
            def listbox_keypress(size, key):
                # åªå¯¹å¯é€‰é¡¹åšå¤„ç†
                idx = self.listbox.focus_position
                logical_idx = self.get_logical_index(idx)
                if key == 'enter':
                    self.open_tag_popup(logical_idx)
                    return None
                return orig_keypress(size, key)
            self.listbox.keypress = listbox_keypress
            logger.info("å¼€å§‹è¿è¡Œä¸»å¾ªç¯")
            loop.run()
        except Exception as e:
            logger.error(f"ç¨‹åºè¿è¡Œå‡ºé”™ï¼š{str(e)}")
            print(f"ç¨‹åºè¿è¡Œå‡ºé”™ï¼š{str(e)}")
            sys.exit(1)

if __name__ == '__main__':
    try:
        logger.info("ç¨‹åºå¯åŠ¨")
        full_names = load_full_names()
        if not full_names:
            logger.error("æ²¡æœ‰æ‰¾åˆ°ä»»ä½•ä»“åº“æ•°æ®")
            print("é”™è¯¯ï¼šæ²¡æœ‰æ‰¾åˆ°ä»»ä½•ä»“åº“æ•°æ®")
            sys.exit(1)
        app = TagApp(full_names)
        app.main()
    except KeyboardInterrupt:
        logger.info("ç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­")
        print("\nç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­")
        sys.exit(0)
    except Exception as e:
        logger.error(f"ç¨‹åºå‡ºé”™ï¼š{str(e)}")
        print(f"ç¨‹åºå‡ºé”™ï¼š{str(e)}")
        sys.exit(1)
